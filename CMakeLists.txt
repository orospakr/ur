cmake_minimum_required(VERSION 3.10)
project(ur VERSION 0.1.0)

# Specify the C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# Define the executable
add_executable(ur src/ur.cpp src/audio/audio.cpp src/game/map.cpp src/game/object.cpp src/ui/menu.cpp src/ui/titlescreen.cpp src/graphics/font.cpp src/graphics/layer.cpp src/graphics/sprite.cpp src/proto/agm.pb.cc)

# SDL:
find_package(SDL2 REQUIRED)
if(SDL2_FOUND)
    message(STATUS "SDL2_INCLUDE_DIRS = ${SDL2_INCLUDE_DIRS}")
    message(STATUS "SDL2_LIBRARIES = ${SDL2_LIBRARIES}")
    target_link_libraries(ur SDL2::SDL2)
else()
    message(FATAL_ERROR "SDL2 not found")
endif()

# SDL_image:
find_package(SDL2_image REQUIRED)
if(SDL2_image_FOUND )
    target_link_libraries(ur SDL2_image::SDL2_image)
else()
    message(FATAL_ERROR "SDL2_image not found")
endif()

# So, finding libopenmpt has to be done differently on Unix vs Windows/vcpkg.
# Upstream libopenmpt does not have a .cmake file, and only offers a pkg-config
# .pc file. However, pkg-config doesn't work well on windows, but interestingly
# when using vcpkg (as one does by default on Windows), a cmake package appears
# to be generated by the libopenmpt vcpkg recipe. So, we can use that if it's
# available, and fall back to pkg-config if now.

# Perhaps upstream will adopt a cmake package someday anyway so trying
# a cmake package first anyway is probably a good idea.

# First, try to find the cmake package:
find_package(libopenmpt CONFIG)

if(libopenmpt_FOUND)
   # it was found with cmake package, so use it:
   target_link_libraries(ur libopenmpt::libopenmpt)
else()
    # Use pkg-config in lieu of cmake package:
    message(STATUS "libopenmpt cmake package not found, trying pkg-config")
    find_package(PkgConfig REQUIRED)
    pkg_check_modules(OPENMPT REQUIRED IMPORTED_TARGET libopenmpt)
    
    if(NOT OPENMPT_FOUND)
        message(FATAL_ERROR "libopenmpt not found using either cmake package or pkg-config")
    endif()

    target_link_libraries(ur PkgConfig::OPENMPT)
endif()


# So, to handle protobuf correctly, we have to do a bit of a hack.
# Background: cmake bundles FindProtobuf.cmake, which is used to find and also includes
# tooling for protobuf. Howver, upstream Protobuf has since added a transitive dependency
# on Abseil/ABSL.  So, when actually linking against protobuf at link time, we need to use
# the package's own cmake and ignore cmake's bundled FindProtobuf.cmake.  However, we still
# need tha latter to build our protos.


# first, find the package/upstream of protobuf's recipe, and use that for
# includes/linking:
find_package(Protobuf CONFIG REQUIRED)
if(Protobuf_FOUND)
    target_link_libraries(ur protobuf::libprotobuf)
endif()

# #  Now, built-in FindCmake to build the protos:
# find_package(Protobuf REQUIRED)

# # Build protos:
# protobuf_generate_cpp(PROTO_SRCS PROTO_HDRS proto/agm.proto)
# message(STATUS "PROTO_SRCS = ${PROTO_SRCS}")
# message(STATUS "PROTO_HDRS = ${PROTO_HDRS}")
# target_sources(ur PRIVATE ${PROTO_SRCS})
# target_include_directories(ur PRIVATE ${CMAKE_CURRENT_BINARY_DIR})

# Include directories
include_directories(src src/audio src/graphics src/ui src/proto)

# Add subdirectory
add_subdirectory(src)

# Link libraries
target_link_libraries(ur)

# Compiler flags
target_compile_options(ur PRIVATE -Wall)

# Game data
file(COPY data DESTINATION ${CMAKE_BINARY_DIR})
